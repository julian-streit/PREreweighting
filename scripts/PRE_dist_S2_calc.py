#!/usr/bin/env python

#### THIS SCRIPT CALCULATES THE DISTANCES AND S2 PARAMETERS FOR THE PRE CALCULATION ####

#### THE ROTAMER FITTING SECTION WAS ADAPTED FROM THE RotamerConvolveMD PYTHON PACKAGE ####
#### THE ROTAMER LIBRARY WAS GENERATED BY THE JESCHKE LAB AND WAS PART OF THE RotamerConvolveMD PACKAGE ####

# REFERENCES FOR ROTAMER fitting/library
# Y. Polyhach, E. Bordignon, and G. Jeschke. Rotamer libraries of spin labelled cysteines for protein studies. Phys. Chem. Chem. Phys., 13:2356-2366, 2011. doi: 10.1039/C0CP01865A.
# L. S. Stelzl, P. W. Fowler, M. S. P. Sansom, and O. Beckstein. Flexible gates generate occluded intermediates in the transport cycle of LacY. J Mol Biol, 426:735-751, 2013. doi: 10.1016/j.jmb.2013.10.024
# RotamerConvolveMD: https://github.com/MDAnalysis/RotamerConvolveMD/tree/master


# Import modules

import numpy as np
import MDAnalysis as md
import MDAnalysis.analysis.align
import MDAnalysis.analysis.distances
import math
sqrt = math.sqrt

# Frames for prediction
frames = np.arange(0,10000)

# import MTSL rotamer library and their weights

# rotamer library must be in any of these formats: trr, dcd, xtc

data_path = './rotamer_data/'

rotamers = md.Universe(data_path+'rotamer1_R1A_298K_2015.pdb',data_path+'rotamer1_R1A_298K_2015.dcd')


# load statistical weights of rotamers

weights = np.loadtxt(data_path+"R1A_298K_populations_2015.dat")


# load ensemble & ribosome coordinates

u = md.Universe('../nc.pdb','../nc_traj.xtc')
ribo = md.Universe('../ribosome.pdb')


# defining a function to fit rotamers

def fit_rotamers(rotamers, protein, site_resid, dcdfile):
    """Produce a temporary trajectory of the rotamers.
    The backbone of the rotamers is fitted to the backbone of the
    spin labelled residues.
    """
    # create an ordered list allowing the rotamer to be fitted onto the backbone of the protein
    fittingSelection = (["name C", "name CA", "name N"],
                        ["protein and name C and resid {0}".format(site_resid),
                        "protein and name CA and resid {0}".format(site_resid),
                        "protein and name N and resid {0}".format(site_resid)
                        ])
    # fit the rotamer library onto the protein
    MDAnalysis.analysis.align.AlignTraj(rotamers, protein,
                                        select=fittingSelection, weights="mass",
                                        filename=dcdfile,
                                        verbose=False).run()
    return dcdfile




# defining a function to find clashing rotamers: second function
# looking for clashes both within the NC and the ribosome


# hydrogens ignored
# protein: all backbone and CB atoms
# ribosome: all RNA and protein backbone & protein CB
# MTSL: sidechain only, except CB and SG

def find_clashing_rotamers(fitted_rotamers, protein, ribosome, site_resid, clash_distance):
    """Detect any rotamer that clashes with the protein."""

    proteinNotSite = protein.select_atoms("protein and not (name H* or name [123]H or type H) "
                "and (name N or name C or name O or name CA or name CB)"
                "and not (resid {} and name CB)".format(site_resid))

    # ribosome atom selection
    ribosomeNotSite = ribosome.select_atoms("not protein or (protein and not (name H* or name [123]H or type H) "
                "and (name N or name C or name O or name CA or name CB))")


    rotamerSel = fitted_rotamers.select_atoms("not (name CA or name N or name C or name O or name CB or name SG or name H* or name [123]H or type H)")

    # coordinates of proteinNotSite atoms
    pNS_pos = np.array([proteinNotSite.positions])[0]

    # coordinates of ribosome atoms
    rNS_pos = np.array([ribosomeNotSite.positions])[0]

    # append proteinNotSite coordinates to ribosome coordinates
    all_pos = np.append(rNS_pos,pNS_pos,axis=0)

    rotamer_clash = []

    for j in range(len(fitted_rotamers.trajectory)):

        # set rotamer frame
        fitted_rotamers.trajectory[j]

        # coordinates of rotamer atoms
        rS_pos = np.array([rotamerSel.positions])[0]

        # distance array between rotamer and protein atoms
        dist_array = MDAnalysis.analysis.distances.distance_array(all_pos,rS_pos)

        rotamer_clash.append(bool(np.min(dist_array)<clash_distance))

    return rotamer_clash, np.sum(rotamer_clash)




# define a function that returns the coordinates of the midpoint between two atoms connected by a straight line

# this is to find the coordinates of the electron, which lies between the N1 and O1 atoms

def find_midpoint(atom1_coord, atom2_coord):

    # atom1_coord = coordinates of atom1 (np.array)
    # atom2_coord = coordinates of atom2 (np.array)

    # vector from atom 2 to atom 1
    vector = atom1_coord - atom2_coord

    # adding 0.5*vector to atom2 will give the midpoint coordinates
    midpoint = atom2_coord + 0.5*vector

    return midpoint





# data point residues
residues = u.select_atoms('resid 10:114 and name HN').resids # MDAnalysis numbering
residues_fln5 = residues + 636 # FLN5 numbering


# data point residues
HN_selection = u.select_atoms('resid 10:114 and name HN')


universes = [u]


# define spinlabel sites and clash distance

spinlabel_sites = [21,35,63,70,84,98,104,108]
clash_distance = 2.5 # Angstrom



rm6_HN = {}
S2 = {}
discarded_frame_ids = {}

calc_rminus6 = lambda dx: (sqrt(dx.dot(dx))*1e-10)**-6
calc_rm6_A = lambda dx: sqrt(dx.dot(dx))**-6

Y2m2 = lambda x: 0.386274 * (x[0]-1j*x[1])**2 / (x[0]**2+x[1]**2+x[2]**2)**2.5
Y2m1 = lambda x: 0.772548 * (x[0]-1j*x[1])*x[2] / (x[0]**2+x[1]**2+x[2]**2)**2.5
Y20 = lambda x: 0.31539 * (2*x[2]**2-x[0]**2-x[1]**2) / (x[0]**2+x[1]**2+x[2]**2)**2.5
Y21 = lambda x: 0.772548 * (x[0]+1j*x[1])*x[2] / (x[0]**2+x[1]**2+x[2]**2)**2.5
Y22 = lambda x: 0.386274 * (x[0]+1j*x[1])**2 / (x[0]**2+x[1]**2+x[2]**2)**2.5


# (2) loop through all labelling sites
for site in spinlabel_sites:

    # (2.1) fitting rotamers to all frames
    print("Fitting MTSL rotamers to all frames & extracting coordinates at residue {}...".format(site+636))

    # initating lists
    all_distances = np.array([])
    all_S2 = np.array([])

    allowed_struc = len(frames)

    label_site_string = 'C{}'.format(site+636)

    discarded_frame_ids[label_site_string] = np.array([])


    #for protein in u.trajectory:
    for i in frames:

        u.trajectory[i]

        #print("Progress {:2.1%}".format((protein.frame+1) / Nstruc), end="\r")
        print("Progress {:2.1%}".format((i+1) / len(frames)), end="\r")

        # extract amide proton coordinates
        dataHN = np.array([HN_selection.positions])

        # extract electro coordinates

        # fit rotamers
        fit_rotamers(rotamers,u,site,'tmptrj1.dcd')

        rotamersSite = md.Universe(data_path+'/rotamer1_R1A_298K_2015.pdb', 'tmptrj1.dcd')

        # find clashing rotamers
        (rotamer_clash, rotamer_clash_total) = find_clashing_rotamers(rotamersSite, u, ribo,
                                                                      site, clash_distance)

        # if the structure sterically does not tolerate a MTSL side-chain discard it
        if rotamer_clash_total == len(rotamers.trajectory):
            allowed_struc -=1
            # appending discarded frame id (0-indexed)
            discarded_frame_ids[label_site_string] = np.append(discarded_frame_ids[label_site_string],np.array([i]))
            continue


        # define the atoms to measure the distances between
        N1 = rotamersSite.select_atoms("name N1")
        O1 = rotamersSite.select_atoms("name O1")

        # find coordinates of non-clashing rotamers
        dataN1 = np.array([N1.ts.positions for ts in rotamersSite.trajectory
                           if not rotamer_clash[ts.frame]])
        dataO1 = np.array([O1.ts.positions for ts in rotamersSite.trajectory
                           if not rotamer_clash[ts.frame]])

        dataSL = find_midpoint(dataN1,dataO1)


        # calculate distances
        dx = dataHN - dataSL

        # apply a little function to calculate r^-6 (m^-6)
        rm6 = np.apply_along_axis(calc_rm6_A, 2, dx) # shape = Nrotamers*Nresi
        distances = np.apply_along_axis(calc_rminus6, 2, dx) # shape = Nrotamers*Nresi
        distances = np.transpose(distances) # Nresi*Nrotamers

        # calculate rotamer weighted average distance
        rotamer_weights = np.array([weights[i] for i in range(len(weights))
                                    if not rotamer_clash[np.where(weights == weights[i])[0][0]]])

        # order parameter
        y2m2 = np.apply_along_axis(Y2m2, 2, dx)
        y2m1 = np.apply_along_axis(Y2m1, 2, dx)
        y20 = np.apply_along_axis(Y20, 2, dx)
        y21 = np.apply_along_axis(Y21, 2, dx)
        y22 = np.apply_along_axis(Y22, 2, dx)


        rminus6_avg = np.average(rm6,weights = rotamer_weights, axis=0)
        y2m2_avg = np.average(y2m2,weights = rotamer_weights, axis=0)
        y2m1_avg = np.average(y2m1,weights = rotamer_weights, axis=0)
        y20_avg = np.average(y20,weights = rotamer_weights, axis=0)
        y21_avg = np.average(y21,weights = rotamer_weights, axis=0)
        y22_avg = np.average(y22,weights = rotamer_weights, axis=0)

        s2 = 4*np.pi/5 / rminus6_avg * (np.abs(y2m2_avg)**2+np.abs(y2m1_avg)**2+np.abs(y20_avg)**2+np.abs(y21_avg)**2+np.abs(y22_avg)**2)

        # appending distances to all_distances
        all_S2 = np.append(all_S2,s2,axis = 0)


        # distances
        product_sum = np.sum((distances*rotamer_weights),axis = 1)

        final_distances = product_sum/np.sum(rotamer_weights)

        # appending distances to all_distances
        all_distances = np.append(all_distances,final_distances,axis = 0)



    # adding the rotamer averaged distances to the dictionary for this labelling site
    print("Formatting data...")
    nslices = HN_selection.n_atoms
    all_distances = all_distances.reshape(allowed_struc,nslices)
    rm6_HN[label_site_string] = all_distances


    all_S2 = all_S2.reshape(allowed_struc,nslices)
    S2[label_site_string] = all_S2

# save data
np.save("./results/rm6_HN_1.npy",rm6_HN)
np.save("./results/S2_1.npy",S2)
np.save("./results/discarded_frames_1.npy",discarded_frame_ids)

print("Done!")
